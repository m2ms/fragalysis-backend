import json
import os
import zipfile
from io import StringIO

from django.db import connections
from django.http import HttpResponse
from django.shortcuts import render
from rest_framework import viewsets
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.conf import settings
from django.http import JsonResponse

from rest_framework.parsers import JSONParser, BaseParser
from rest_framework.exceptions import ParseError
from rest_framework.views import APIView

from django.views import View

from celery.result import AsyncResult

from api.security import ISpyBSafeQuerySet
from api.utils import get_params, get_highlighted_diffs

from viewer.models import (
    Molecule,
    Protein,
    Compound,
    Target,
    ActionType,
    SessionProject,
    SessionActions,
    Snapshot,
    SnapshotActions,
    ComputedMolecule,
    ComputedSet,
    CSetKeys,
    NumericalScoreValues,
    ScoreDescription,
    File
)
from viewer import filters
from .forms import CSetForm, UploadKeyForm, CSetUpdateForm

from .tasks import *

import pandas as pd

from viewer.serializers import (
    MoleculeSerializer,
    ProteinSerializer,
    CompoundSerializer,
    TargetSerializer,
    MolImageSerialzier,
    CmpdImageSerialzier,
    ProtMapInfoSerialzer,
    ProtPDBInfoSerialzer,
    ProtPDBBoundInfoSerialzer,
    VectorsSerializer,
    GraphSerializer,
    ActionTypeSerializer,
    SessionProjectWriteSerializer,
    SessionProjectReadSerializer,
    SessionActionsSerializer,
    SnapshotReadSerializer,
    SnapshotWriteSerializer,
    SnapshotActionsSerializer,
    FileSerializer,
    ComputedSetSerializer,
    ComputedMoleculeSerializer,
    NumericalScoreSerializer,
    ScoreDescriptionSerializer,
    TextScoreSerializer,
    ComputedMolAndScoreSerializer,
)


class VectorsView(ISpyBSafeQuerySet):
    """ DjagnoRF view for vectors

    Methods
    -------
    url:
        api/vector
    queryset:
        `viewer.models.Molecule.objects.filter()`
    filter fields:
        - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
        - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
        - `viewer.models.Molecule.smiles` - ?smiles=<str>
        - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
    returns:
        vectors for a given molecule generated by `frag.network.generate.get_3d_vects_for_mol()` (JSON)

    """
    queryset = Molecule.objects.filter()
    serializer_class = VectorsSerializer
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = ("prot_id", "cmpd_id", "smiles", "prot_id__target_id", "mol_groups")


class GraphView(ISpyBSafeQuerySet):
    """ DjagnoRF view for graph

    Methods
    -------
    url:
        api/graph
    queryset:
        `viewer.models.Molecule.objects.filter()`
    filter fields:
        - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
        - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
        - `viewer.models.Molecule.smiles` - ?smiles=<str>
        - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
        - `viewer.models.Molecule.mol_groups` - ?mol_groups=<int>,<int>
    returns:
        graph network results for given molecule from `frag.network.query.get_full_graph()` (JSON)

    example output:

        .. code-block:: javascript

            "results": [
            {
                "id": 13684,
                "graph": {
                    "COc1ccc(CC(=O)Nc2cc(Cl)cc([Xe])c2)cc1_1_ADDITION": {
                        "vector": "COC1CCC(CC(O)NC2CC(Cl)CC([103Xe])C2)CC1",
                        "addition": [
                            {
                                "change": "F[103Xe]",
                                "end": "COc1ccc(CC(=O)Nc2cc(F)cc(Cl)c2)cc1"
                            },
                            {
                                "change": "Cl[104Xe]",
                                "end": "COc1ccc(CC(=O)Nc2cc(Cl)cc(Cl)c2)cc1"
                            },
                            {
                                "change": "Cl[103Xe]",
                                "end": "COc1ccc(CC(=O)Nc2cc(Cl)cc(Cl)c2)cc1"
                            },
                            {
                                "change": "OC(O)[104Xe]",
                                "end": "COc1ccc(CC(=O)Nc2cc(Cl)cc(C(=O)O)c2)cc1"
                            },
                            {
                                "change": "Br[104Xe]",
                                "end": "COc1ccc(CC(=O)Nc2cc(Cl)cc(Br)c2)cc1"
                            }
                        ]
                    },]

    """
    queryset = Molecule.objects.filter()
    serializer_class = GraphSerializer
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = ("prot_id", "cmpd_id", "smiles", "prot_id__target_id", "mol_groups")


class MolImageView(ISpyBSafeQuerySet):
    """ DjagnoRF view for molecule images

    Methods
    -------
    url:
        api/molimg
    queryset:
        `viewer.models.Molecule.objects.filter()`
    filter fields:
        - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
        - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
        - `viewer.models.Molecule.smiles` - ?smiles=<str>
        - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
        - `viewer.models.Molecule.mol_groups` - ?mol_groups=<int>,<int>
    returns:
        SVG image text for query molecule generated by `api.utils.draw_mol()` (JSON)

    example output:

        .. code-block:: javascript

             "results": [
                    {"id": 13912,
                        "mol_image": "<?xml version='1.0' encoding='iso-8859-1'?><svg version='1.1' nk'..."}]
    """
    queryset = Molecule.objects.filter()
    serializer_class = MolImageSerialzier
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = ("prot_id", "cmpd_id", "smiles", "prot_id__target_id", "mol_groups")


class CompoundImageView(ISpyBSafeQuerySet):
    """ DjagnoRF view for compound images

   Methods
   -------
   url:
       api/cmpdimg
   queryset:
       `viewer.models.Compound.objects.filter()`
   filter fields:
       - `viewer.models.Molecule.smiles` - ?smiles=<str>
   returns:
       SVG image text for query compound generated by `api.utils.draw_mol()` (JSON)

   example output:

       .. code-block:: javascript

        "results": [
                {"id": 13912,
                    "mol_image": "<?xml version='1.0' encoding='iso-8859-1'?><svg version='1.1' nk'..."}]

    """
    queryset = Compound.objects.filter()
    serializer_class = CmpdImageSerialzier
    filter_permissions = "project_id"
    filter_fields = ("smiles",)


class ProteinMapInfoView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve map info (file) for a given protein

   Methods
   -------
   url:
       api/protmap
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns:
       If a map file has been uploaded for the protein `map_info.path.read()` (JSON)

   """
    queryset = Protein.objects.filter()
    serializer_class = ProtMapInfoSerialzer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "prot_type")


class ProteinPDBInfoView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve apo pdb info (file) for a given protein

   Methods
   -------
   url:
       api/protpdb
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns: JSON
       - id: id of the protein object
       - pdb_data: If a pdb file has been uploaded for the protein `bound_info.path.read()`
       - prot_type: type of protein (e.g. AP for apo - see docs for model)

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 27387,
                "pdb_data": "REMARK warning: chains may be ommitted for alignment REMARK ...",
                "prot_type": "AP"
            },]

   """
    queryset = Protein.objects.filter()
    serializer_class = ProtPDBInfoSerialzer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "prot_type")


class ProteinPDBBoundInfoView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve bound pdb info (file) for a given protein

   Methods
   -------
   url:
       api/protpdbbound
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns: JSON
       - id: id of the protein object
       - pdb_data: If a pdb file has been uploaded for the protein `bound_info.path.read()`
       - prot_type: type of protein (e.g. AP for apo - see docs for model)

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 27387,
                "pdb_data": "REMARK warning: chains may be ommitted for alignment REMARK ...",
                "prot_type": "AP"
            },]

   """
    queryset = Protein.objects.filter()
    serializer_class = ProtPDBBoundInfoSerialzer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "prot_type")


class TargetView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve info about targets

       Methods
       -------
       url:
           api/targets
       queryset:
           `viewer.models.Target.objects.filter()`
       filter fields:
           - `viewer.models.Target.title` - ?title=<str>
       returns: JSON
           - id: id of the target object
           - title: name of the target
           - project_id: list of the ids of the projects the target is linked to
           - protein_set: list of the ids of the protein sets the target is linked to
           - template_protein: the template protein displayed in fragalysis front-end for this target
           - metadata: link to the metadata file for the target if it was uploaded
           - zip_archive: link to the zip archive of the uploaded data

       example output:

           .. code-block:: javascript

               "results": [
                {
                    "id": 62,
                    "title": "Mpro",
                    "project_id": [
                        2
                    ],
                    "protein_set": [
                        29281,
                        29274,
                        29259,
                        29305,
                        ...,
                    ],
                    "template_protein": "/media/pdbs/Mpro-x10417_0_apo.pdb",
                    "metadata": "http://fragalysis.diamond.ac.uk/media/metadata/metadata_2FdP5OJ.csv",
                    "zip_archive": "http://fragalysis.diamond.ac.uk/media/targets/Mpro.zip"
                }
            ]

       """
    queryset = Target.objects.filter()
    serializer_class = TargetSerializer
    filter_permissions = "project_id"
    filter_fields = ("title",)


class MoleculeView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve info about molecules

   Methods
   -------
   url:
       api/molecules
   queryset:
       `viewer.models.Molecule.objects.filter()`
   filter fields:
       - `viewer.models.Molecule.prot_id` - ?prot_id=<int>
       - `viewer.models.Molecule.cmpd_id` - ?cmpd_id=<int>
       - `viewer.models.Molecule.smiles` - ?smiles=<string>
       - `viewer.models.Molecule.prot_id__target_id` - ?target_id=<int>
       - `viewer.models.Molecule.mol_type` - ?mol_type=<str>
       - `viewer.models.Molecule.mol_groups` - ?mol_groups=<int>,<int>
   returns: JSON
       - id: id of the target object
       - smiles: smiles string of the molecule
       - cmpd_id: id of the related 2D compound object
       - prot_id: id of the related protein object
       - protein_code: code of the related protein object
       - mol_type: type of molecule - see Molecule model docs
       - molecule_protein: filepath of the apo protein structure for the molecule
       - lig_id: residue label for the ligand
       - chain_id: chain in the pdb file that the ligand belongs to
       - sdf_info: 3D coordinated of the molecule in MDL file format
       - x_com: x-coordinate for molecule centre of mass
       - y_com: y-coordinate for molecule centre of mass
       - z_com: z-coordinate for molecule centre of mass
       - mw: molecular weight
       - logp: LogP
       - tpsa: Topological Polar Surface Area
       - ha: heavy atom count
       - hacc: hydrogen-bond acceptors
       - hdon: hydrogen-bond donors
       - rots: number of rotatable bonds
       - rings: number of rings
       - velec: number of valence electrons

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 13912,
                "smiles": "CN(C)c1ccc(C(=O)Nc2ccccn2)cc1",
                "cmpd_id": 796,
                "prot_id": 13923,
                "protein_code": "NUDT7A_Crude-x2226_2",
                "mol_type": "PR",
                "molecule_protein": "/media/pdbs/NUDT7A_Crude-x2226_2_apo_x5GxiLq.pdb",
                "lig_id": "LIG",
                "chain_id": "Z",
                "sdf_info": "     RDKit          3D 18 19  0  0  0  0  0  0  0  0999...",
                "x_com": null,
                "y_com": null,
                "z_com": null,
                "mw": 241.12,
                "logp": 2.4,
                "tpsa": 45.23,
                "ha": 18,
                "hacc": 3,
                "hdon": 1,
                "rots": 3,
                "rings": 2,
                "velec": 92
            },]

   """
    queryset = Molecule.objects.filter()
    serializer_class = MoleculeSerializer
    filter_permissions = "prot_id__target_id__project_id"
    filter_fields = (
        "prot_id",
        "cmpd_id",
        "smiles",
        "prot_id__target_id",
        "mol_type",
        "mol_groups",
    )


class CompoundView(ISpyBSafeQuerySet):
    """ DjagnoRF view for compound info

   Methods
   -------
   url:
       api/compounds
   queryset:
       `viewer.models.Compound.objects.filter()`
   filter fields:
       - `viewer.models.Molecule.smiles` - ?smiles=<str>
   returns:
       - id: id for compound object
       - inchi: inchi key for compound
       - smiles: smiles string for compound
       - mol_log_p: LogP for compound
       - num_h_acceptors: number of hydrogen-bond acceptors
       - num_h_donors: number of hydrogen-bond donors

   example output:

       .. code-block:: javascript

        "results": [
        {
            "id": 1,
            "inchi": "InChI=1S/C9H15NOS/c1-7(11)5-10-6-9-4-3-8(2)12-9/h3-4,7,10-11H,5-6H2,1-2H3/t7-/m0/s1",
            "smiles": "Cc1ccc(CNC[C@H](C)O)s1",
            "mol_log_p": 1.52692,
            "mol_wt": 185.0874351,
            "num_h_acceptors": 3,
            "num_h_donors": 2
        },]

    """
    queryset = Compound.objects.filter()
    serializer_class = CompoundSerializer
    filter_permissions = "project_id"
    filter_fields = ("smiles",)


class ProteinView(ISpyBSafeQuerySet):
    """ DjagnoRF view to retrieve bound pdb info (file) for a given protein

   Methods
   -------
   url:
       api/proteins
   queryset:
       `viewer.models.Protein.objects.filter()`
   filter fields:
       - `viewer.models.Protein.code` - ?code=<str>
       - `viewer.models.Protein.target_id` - ?target_id=<int>
       - `viewer.models.Protein.prot_type` - ?prot_type=<str>
   returns: JSON
       - id: id of the protein object
       - code: the code/name of the protein
       - target_id: the id of the related target object
       - prot_type: the type of protein (e.g. AP for apo)
       - pdb_info: link to the apo pdb file
       - bound_info: link to the bound pdb file
       - mtz_info: link to the mtz file
       - map_info: link to the map file
       - cif_info: link to the cif file

   example output:

       .. code-block:: javascript

           "results": [
            {
                "id": 14902,
                "code": "XX02KALRNA-x1376_1",
                "target_id": 51,
                "prot_type": "AP",
                "pdb_info": "http://fragalysis.diamond.ac.uk/media/pdbs/XX02KALRNA-x1376_1_apo_9VSCvR8.pdb",
                "bound_info": "http://fragalysis.diamond.ac.uk/media/bound/XX02KALRNA-x1376_1_bound_6xmXkUm.pdb",
                "mtz_info": null,
                "map_info": null,
                "cif_info": null
            },]

   """
    queryset = Protein.objects.filter()
    serializer_class = ProteinSerializer
    filter_permissions = "target_id__project_id"
    filter_fields = ("code", "target_id", "prot_type")


def react(request):
    """
    :param request:
    :return:
    """
    return render(request, "viewer/react_temp.html")


# email cset upload key
def cset_key(request):
    """ View to render and control viewer/generate-key.html - a page allowing an upload key to be generated for a user
    allowing upload of computed sets

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: generates an upload key, emails it to the user, and informs the user that this will happen
    url:
       viewer/cset_key
    template:
        viewer/generate-key.html
    request params:
        - contact_email (django.forms.FormField): user contact email
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.UploadKeyForm`
        - message (str): A message rendered in the template. Informs the user that their upload key will be emailed

    """

    form = UploadKeyForm()
    if request.method == 'POST':
        form = UploadKeyForm(request.POST)
        email = request.POST['contact_email']
        new_key = CSetKeys()
        new_key.user = email
        new_key.save()
        key_value = new_key.uuid

        from django.core.mail import send_mail
        from django.conf import settings

        subject = 'Fragalysis: upload compound set key'
        message = 'Your upload key is: ' + str(
            key_value) + ' store it somewhere safe. Only one key will be issued per user'
        email_from = settings.EMAIL_HOST_USER
        recipient_list = [email, ]
        send_mail(subject, message, email_from, recipient_list)

        msg = 'Your key will be emailed to: <b>' + email + '</b>'

        return render(request, 'viewer/generate-key.html', {'form': form, 'message': msg})
    return render(request, 'viewer/generate-key.html', {'form': form, 'message': ''})


def save_pdb_zip(pdb_file):
    zf = zipfile.ZipFile(pdb_file)
    zip_lst = zf.namelist()
    zfile = {}

    for filename in zip_lst:
        # only handle pdb files
        if filename.split('.')[-1] == 'pdb':
            # Test if Protein object already exists
            test_pdb_code = filename.split('/')[-1].replace('.pdb', '')
            test_prot_objs = Protein.objects.filter(code=test_pdb_code)

            # If no prot obj found then save to tmp/ file and link pdb_code with
            # pdb_path in dict
            if len(test_prot_objs) == 0:
                # Save pdb file in /tmp folder
                pdb_path = default_storage.save('tmp/' + filename.split('/')[-1],
                                                ContentFile(zf.read(filename)))
                zfile[test_pdb_code] = pdb_path

            # If prot object/s exist then update dict with pdb path
            if len(test_prot_objs) != 0:
                zfile[test_pdb_code] = str(test_prot_objs[0].pdb_info)

    # Close the zip file
    if zf:
        zf.close()

    return zfile


def save_sdf(myfile):
    name = myfile.name
    path = default_storage.save('tmp/' + name, ContentFile(myfile.read()))
    tmp_file = str(os.path.join(settings.MEDIA_ROOT, path))

    return tmp_file



class UpdateCSet(View):
    """ View to allow addition of new molecules/pdb files to an existing Computed Set

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: validates and optionally uploads the computed set that the user provides via the template form
    url:
        viewer/upload_cset
    template:
        viewer/upload-cset.html
    request params:
        - target_name (`django.forms.CharField`): Name of the existing fragalysis target to add the computed set to
        - sdf_file (`django.forms.FileField`): SDF file of all computed molecules to upload for the computed set
        - pdb_zip (`django.forms.FileField`): zip file of apo pdb files referenced in the ref_pdb field for molecules in sdf_file (optional)
        - submit_choice (`django.forms.CharField`): 0 to validate, 1 to validate and upload
        - upload_key (`django.forms.CharField`): users unique upload key, generated by `viewer.views.cset_key`
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.CSetForm`
        - validate_task_id (str): celery task id for validation step
        - validate_task_status (str): celery task status for validation step
        - upload_task_id (str): celery task id for upload step
        - upload_task_status (str): celery task status for upload step

    """
    def get(self, request):
        form = CSetUpdateForm()
        existing_sets = ComputedSet.objects.all()
        return render(request, 'viewer/update-cset.html', {'form': form, 'sets': existing_sets})

    def post(self, request):
        check_services()
        zfile = None
        zf = None
        cset = None
        form = CSetUpdateForm(request.POST, request.FILES)
        context = {}
        if form.is_valid():

            # get all of the variables needed from the form
            myfile = request.FILES['sdf_file']
            target = request.POST['target_name']

            # get update choice
            update_set = request.POST['update_set']

            if 'pdb_zip' in list(request.FILES.keys()):
                pdb_file = request.FILES['pdb_zip']
            else:
                pdb_file = None

            # if there is a zip file of pdbs, check it for .pdb files, and ignore others
            if pdb_file:
               zfile = save_pdb_zip(pdb_file)

            # save uploaded sdf to tmp storage
            tmp_file = save_sdf(myfile)

            task_update = add_cset_mols.s(cset=update_set, target=target, sdf_file=tmp_file, zfile=zfile).apply_async()

            context = {}
            context['update_task_id'] = task_update.id
            context['update_task_status'] = task_update.status

            # Update client side with task id and status
            return render(request, 'viewer/update-cset.html', context)

        context['form'] = form
        return render(request, 'viewer/update-cset.html', context)


class UploadCSet(View):
    """ View to render and control viewer/upload-cset.html  - a page allowing upload of computed sets. Validation and
    upload tasks are defined in `viewer.compound_set_upload`, `viewer.sdf_check` and `viewer.tasks` and the task
    response handling is done by `viewer.views.ValidateTaskView` and `viewer.views.UploadTaskView`

    Methods
    -------
    allowed requests:
        - GET: renders form
        - POST: validates and optionally uploads the computed set that the user provides via the template form
    url:
        viewer/upload_cset
    template:
        viewer/upload-cset.html
    request params:
        - target_name (`django.forms.CharField`): Name of the existing fragalysis target to add the computed set to
        - sdf_file (`django.forms.FileField`): SDF file of all computed molecules to upload for the computed set
        - pdb_zip (`django.forms.FileField`): zip file of apo pdb files referenced in the ref_pdb field for molecules in sdf_file (optional)
        - submit_choice (`django.forms.CharField`): 0 to validate, 1 to validate and upload
        - upload_key (`django.forms.CharField`): users unique upload key, generated by `viewer.views.cset_key`
    context:
        - form (`django.Forms.form`): instance of `viewer.forms.CSetForm`
        - validate_task_id (str): celery task id for validation step
        - validate_task_status (str): celery task status for validation step
        - upload_task_id (str): celery task id for upload step
        - upload_task_status (str): celery task status for upload step

    """

    def get(self, request):

        # test = TargetView().get_queryset(request=request)
        # targets = request.get('/api/targets/')
        # int(targets)
        form = CSetForm()
        existing_sets = ComputedSet.objects.all()
        return render(request, 'viewer/upload-cset.html', {'form': form, 'sets': existing_sets})

    def post(self, request):
        check_services()
        zfile = None
        zf = None
        cset = None
        form = CSetForm(request.POST, request.FILES)
        context = {}
        if form.is_valid():
            # get the upload key
            # key = request.POST['upload_key']
            # all_keys = CSetKeys.objects.all()
            # if it's not valid, return a message
            # if key not in [str(key.uuid) for key in all_keys]:
            #     html = "<br><p>You either didn't provide an upload key, or it wasn't valid. Please try again (email rachael.skyner@diamond.ac.uk to obtain an upload key)</p>"
            #     return render(request, 'viewer/upload-cset.html', {'form': form, 'table': html})

            # get all of the variables needed from the form
            myfile = request.FILES['sdf_file']
            target = request.POST['target_name']
            choice = request.POST['submit_choice']

            # get update choice
            update_set = request.POST['update_set']

            if 'pdb_zip' in list(request.FILES.keys()):
                pdb_file = request.FILES['pdb_zip']
            else:
                pdb_file = None

            # if there is a zip file of pdbs, check it for .pdb files, and ignore others
            if pdb_file:

                zfile = save_pdb_zip(pdb_file)

            # save uploaded sdf to tmp storage
            tmp_file = save_sdf(myfile)

            # Settings for if validate option selected
            if str(choice) == '0':
                # Start celery task
                task_validate = validate.delay(tmp_file, target=target, zfile=zfile, update=update_set)

                context = {}
                context['validate_task_id'] = task_validate.id
                context['validate_task_status'] = task_validate.status

                # Update client side with task id and status
                return render(request, 'viewer/upload-cset.html', context)

            # if it's an upload, run the compound set task
            if str(choice) == '1':
                # Start chained celery tasks. NB first function passes tuple
                # to second function - see tasks.py
                task_upload = (
                            validate.s(tmp_file, target=target, zfile=zfile, update=update_set) | process_compound_set.s()).apply_async()

                context = {}
                context['upload_task_id'] = task_upload.id
                context['upload_task_status'] = task_upload.status

                # Update client side with task id and status
                return render(request, 'viewer/upload-cset.html', context)

        context['form'] = form
        return render(request, 'viewer/upload-cset.html', context)


class ValidateTaskView(View):
    """ View to handle dynamic loading of validation results from `viewer.tasks.validate` - the validation of files
    uploaded to viewer/upload_cset

    Methods
    -------
    allowed requests:
        - GET: takes a task id, checks it's status and returns the status, and result if the task is complete
    url:
        validate_task/<validate_task_id>
    template:
        viewer/upload-cset.html
    """
    def get(self, request, validate_task_id):
        """ Get method for `ValidateTaskView`. Takes a validate task id, checks it's status and returns the status,
        and result if the task is complete

        Parameters
        ----------
        request: request
            Context sent by `UploadCSet`
        validate_task_id: str
            task id provided by `UploadCSet`

        Returns
        -------
        response_data: JSON
            response data (dict) in JSON format:
                - if status = 'RUNNING':
                    - validate_task_status (str): task.status
                    - validate_task_id (str): task.id
                - if status = 'FAILURE':
                    - validate_task_status (str): task.status
                    - validate_task_id (str): task.id
                    - validate_traceback (str): task.traceback
                - if status = 'SUCCESS':
                    - validate_task_status (str): task.status
                    - validate_task_id (str): task.id
                    - html (str): html of task outcome - success message or html table of errors & fail message

        """
        task = AsyncResult(validate_task_id)
        response_data = {'validate_task_status': task.status,
                         'validate_task_id': task.id}

        if task.status == 'FAILURE':
            result = task.traceback
            response_data['validate_traceback'] = str(result)

            return JsonResponse(response_data)

        # Check if results ready
        if task.status == "SUCCESS":
            results = task.get()
            # NB get tuple from validate task
            validate_dict = results[0]
            validated = results[1]
            if validated:
                response_data['html'] = 'Your data was validated. \n It can now be uploaded using the upload option.'

                return JsonResponse(response_data)

            if not validated:
                # set pandas options to display all column data
                pd.set_option('display.max_colwidth', -1)

                table = pd.DataFrame.from_dict(validate_dict)
                html_table = table.to_html()
                html_table += '''<p> Your data was <b>not</b> validated. The table above shows errors</p>'''

                response_data["html"] = html_table

                return JsonResponse(response_data)

        return JsonResponse(response_data)


class UpdateTaskView(View):

    def get(self, request, update_task_id):
        task = AsyncResult(update_task_id)
        response_data = {'update_task_status': task.status,
                         'update_task_id': task.id}

        result = 'Running...'

        if task.status == 'FAILURE':
            result = task.traceback
            response_data['result'] = str(result)

        if task.status == 'SUCCESS':
            result = task.get()

        response_data['result'] = str(result)

        return JsonResponse(response_data)


class UploadTaskView(View):
    """ View to handle dynamic loading of upload results from `viewer.tasks.process_compound_set` - the upload of files
    for a computed set by a user at viewer/upload_cset

    Methods
    -------
    allowed requests:
        - GET: takes a task id, checks it's status and returns the status, and result if the task is complete
    url:
        upload_task/<uploads_task_id>
    template:
        viewer/upload-cset.html
    """
    def get(self, request, upload_task_id):
        """ Get method for `UploadTaskView`. Takes an upload task id, checks it's status and returns the status,
        and result if the task is complete

        Parameters
        ----------
        request: request
            Context sent by `UploadCSet`
        upload_task_id: str
            task id provided by `UploadCSet`

        Returns
        -------
        response_data: JSON
            response data (dict) in JSON format:
                - if status = 'RUNNING':
                    - upload_task_status (str): task.status
                    - upload_task_id (str): task.id
                - if status = 'FAILURE':
                    - upload_task_status (str): task.status
                    - upload_task_id (str): task.id
                    - upload_traceback (str): task.traceback
                - if status = 'SUCCESS':
                    - upload_task_status (str): task.status
                    - upload_task_id (str): task.id
                    - if results are a list (data was not validated):
                        - validated (str): 'Not validated'
                        - html (str): html table of validation errors
                    - if results are a string (data was validated and uploaded:
                        - validated (str): 'Validated'
                        - results (dict): results
                        - results['cset_download_url'] (str): download url for computed set sdf file
                        - results['pset_download_url'] (str): download url for computed set pdb files (zip)
                    - if results are not string or list:
                        - processed (str): 'None'
                        - html (str): message to tell the user their data was not processed

        """
        task = AsyncResult(upload_task_id)
        response_data = {'upload_task_status': task.status,
                         'upload_task_id': task.id}

        if task.status == 'FAILURE':
            result = task.traceback
            response_data['upload_traceback'] = str(result)

            return JsonResponse(response_data)

        if task.status == 'SUCCESS':

            results = task.get()

            # Check for d,v vs csetname output
            if isinstance(results, list):
                # Get dictionary results
                validate_dict = results[0]

                # set pandas options to display all column data
                pd.set_option('display.max_colwidth', -1)

                table = pd.DataFrame.from_dict(validate_dict)
                html_table = table.to_html()
                html_table += '''<p> Your data was <b>not</b> validated. The table above shows errors</p>'''

                response_data['validated'] = 'Not validated'
                response_data['html'] = html_table

                return JsonResponse(response_data)

            # Check for d,v vs csetname output
            # Check in with Rachael if we are expecting a string here?
            if isinstance(results, str):
                cset_name = results
                cset = ComputedSet.objects.get(name=cset_name)

                submitter = cset.submitter
                name = cset.unique_name
                response_data['validated'] = 'Validated'
                response_data['results'] = {}
                response_data['results']['cset_download_url'] = '/viewer/compound_set/%s' % name
                response_data['results']['pset_download_url'] = '/viewer/protein_set/%s' % name

                return JsonResponse(response_data)

            else:

                html_table = '''<p> Your data was <b>not</b> processed.</p>'''
                response_data['processed'] = 'None'
                response_data['html'] = html_table
                return JsonResponse(response_data)

        return JsonResponse(response_data)


def img_from_smiles(request):
    """ View to generate a 2D molecule image for a given smiles string

    Methods
    -------
    allowed requests:
        - GET: generate a 2D molecule image for a given smiles string
    url:
        viewer/img_from_smiles
    request params:
        - smiles (str): smiles string to generate image for

    Returns
    -------
    HTTPResponse (str):
        - if smiles provided:
            string for SVG image of molecule
        - if smiles not provided:
            "Please insert SMILES"

    """
    if "smiles" in request.GET:
        smiles = request.GET["smiles"]
        if smiles:
            return get_params(smiles, request)
        else:
            return HttpResponse("Please insert SMILES")
    else:
        return HttpResponse("Please insert SMILES")


def highlight_mol_diff(request):
    """ View to generate a 2D molecule image highlighting the difference between a reference and new molecule

    Methods
    -------
    allowed requests:
        - GET: generate a 2D molecule image highlighting the difference between a reference and new molecule
    url:
        viewer/highlight_mol_diff
    request params:
        - prb_smiles (str): smiles string to generate image for
        - ref_smiles (str): reference smiles for highlighting by MCS

    Returns
    -------
    HTTPResponse (str):
        - if smiles provided:
            string for SVG image of molecule
        - if smiles not provided:
            "Please insert smiles for reference and probe"

    """
    if 'prb_smiles' and 'ref_smiles' in request.GET:
        return HttpResponse(get_highlighted_diffs(request))
    else:
        return HttpResponse("Please insert smiles for reference and probe")


def similarity_search(request):
    if "smiles" in request.GET:
        smiles = request.GET["smiles"]
    else:
        return HttpResponse("Please insert SMILES")
    if "db_name" in request.GET:
        db_name = request.GET["db_name"]
    else:
        return HttpResponse("Please insert db_name")
    sql_query = """SELECT sub.*
  FROM (
    SELECT rdk.id,rdk.structure,rdk.idnumber
      FROM vendordbs.enamine_real_dsi_molfps AS mfp
      JOIN vendordbs.enamine_real_dsi AS rdk ON mfp.id = rdk.id
      WHERE m @> qmol_from_smiles(%s) LIMIT 1000
  ) sub;"""
    with connections[db_name].cursor() as cursor:
        cursor.execute(sql_query, [smiles])
        return HttpResponse(json.dumps(cursor.fetchall()))


def get_open_targets(request):
    """ View to return a list of all open targets

    Methods
    -------
    allowed requests:
        - GET: return a list of all open targets
    url:
        viewer/open_targets
    request params:
        None

    Returns
    -------
    HTTPResponse (JSON/dict):
        - target_names (list): list of open targets
        - target_ids (list): list of ids for open targets in same order as target_names

    """
    targets = Target.objects.all()
    target_names = []
    target_ids = []

    for t in targets:
        for p in t.project_id.all():
            if 'OPEN' in p.title:
                target_names.append(t.title)
                target_ids.append(t.id)

    return HttpResponse(json.dumps({'target_names': target_names, 'target_ids': target_ids}))


def cset_download(request, name):
    """ View to download an SDF file of a computed set by name

    Methods
    -------
    allowed requests:
        - GET: return the SDF file as a download
    url:
        viewer/compound_set/(<name>)
    request params:
        - name (str): the name of the computed set to download

    Returns
    -------
    Response (attachment; text/plain):
        - <name>.sdf: sdf file for the computed set

    """
    compound_set = ComputedSet.objects.get(unique_name=name)
    filepath = compound_set.submitted_sdf
    with open(filepath.path, 'r') as fp:
        data = fp.read()
    filename = 'compund-set_' + name + '.sdf'
    response = HttpResponse(content_type='text/plain')
    response['Content-Disposition'] = 'attachment; filename=%s' % filename  # force browser to download file
    response.write(data)
    return response


def pset_download(request, name):
    """ View to download a zip file of all protein structures (apo) for a computed set

     Methods
     -------
     allowed requests:
         - GET: return the zip file as a download
     url:
         viewer/compound_set/(<name>)
     request params:
         - name (str): the name of the computed set to download

     Returns
     -------
     Response (attachment; application/zip):
         - <name>.zip: zip file for the computed set

     """
    response = HttpResponse(content_type='application/zip')
    filename = 'protein-set_' + name + '.zip'
    response['Content-Disposition'] = 'filename=%s' % filename  # force browser to download file

    compound_set = ComputedSet.objects.get(unique_name=name)
    computed = ComputedMolecule.objects.filter(computed_set=compound_set)
    pdb_filepaths = list(set([c.pdb_info.path for c in computed]))

    buff = StringIO()
    zip_obj = zipfile.ZipFile(buff, 'w')

    for fp in pdb_filepaths:
        data = open(fp, 'r').read()
        zip_obj.writestr(fp.split('/')[-1], data)
    zip_obj.close()

    buff.flush()
    ret_zip = buff.getvalue()
    buff.close()
    response.write(ret_zip)

    return response

# Start of ActionType
class ActionTypeView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about action types available to users (GET)

    Methods
    -------
    url:
        api/action-types
    queryset:
        `viewer.models.ActionType.objects.filter()`
    methods:
        `get, head`
    filter fields:
        - `viewer.models.ActionType.description` - ?description=<str>
        - `viewer.models.ActionType.active` - ?active=<boolean>
        - `viewer.models.ActionType.activation_date` - ?date=<str>

    returns: JSON
        - id: id of the action type
        - description: The description of the action type
        - active: True if action type is active, False if not
        - activation_date: The datetime the action type became active

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1,
                    "description": "Test Action TYpe",
                    "active": true,
                    "activation_date": "2020-10-06T14:42:00Z"
                }
            ]

   """
    queryset = ActionType.objects.filter()
    serializer_class = ActionTypeSerializer

    # POST method allowed for flexibility in the PoC. In the final design we may want to prevent the POST/PUT methods from being used
    # for action types so that these can only be updated via the admin panel.
    #    http_method_names = ['get', 'head']

    filter_fields = '__all__'


# Start of Session Project
class SessionProjectsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about user projects (collection of sessions) (GET). Also used for saving
    project information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/session-projects
    queryset:
        `viewer.models.SessionProject.objects.filter()`
    filter fields:
        - `viewer.models.SessionProject.title` - ?title=<str>
        - `viewer.models.SessionProject.init_date` - ?date=<str>
        - `viewer.models.SessionProject.description` - ?description=<str>
        - `viewer.models.SessionProject.target` - ?target=<int>
        - `viewer.models.SessionProject.author` - ?author=<str>
        - `viewer.models.SessionProject.tags` - ?tags=<list>
    returns: JSON
        - id: id of the project
        - target: dict of target info:
            - id: target id
            - title: name of the target protein
            - project_id: id of the project
            - protein_set: list of protein objects associated with the target
            - template_protein: link to the file used as the reference in fragalysis frontend
            - metadata: link to the target metadata file
            - zip_archive: link to the zip archive of uploaded files
        - author: name of the author that created the session
        - title: title for the project
        - init_date: timestamp for when the project was created
        - description: author defined description of the project
        - tags: list of tags given to the project by the author

    example output:

        .. code-block:: javascript

            "results": [
            {
                "id": 122,
                "target": {
                    "id": 62,
                    "title": "Mpro",
                    "project_id": [
                        2
                    ],
                    "protein_set": [
                        29281,
                        29274,
                        29259,
                        29305,
                        29250,
                        ...,
                    ],
                    "template_protein": "/media/pdbs/Mpro-x10417_0_apo.pdb",
                    "metadata": "http://fragalysis.diamond.ac.uk/media/metadata/metadata_2FdP5OJ.csv",
                    "zip_archive": "http://fragalysis.diamond.ac.uk/media/targets/Mpro.zip"
                },
                "author": null,
                "title": "READ_ONLY",
                "init_date": "2020-07-09T19:52:10.506119Z",
                "description": "READ_ONLY",
                "tags": "[]"
            },]

   """
    queryset = SessionProject.objects.filter()

    def get_serializer_class(self):
        """Determine which serializer to use based on whether the request is a GET or a POST, PUT or PATCH request

        Returns
        -------
        Serializer (rest_framework.serializers.ModelSerializer):
            - if GET: `viewer.serializers.SessionProjectReadSerializer`
            - if other: `viewer.serializers.SessionProjectWriteSerializer`
        """
        if self.request.method in ['GET']:
            # GET
            return SessionProjectReadSerializer
        # (POST, PUT, PATCH)
        return SessionProjectWriteSerializer

    filter_permissions = "target_id__project_id"
    filter_fields = '__all__'


class SessionActionsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about actions relating to sessions_project (GET). Also used for saving
    project action information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/session-actions
    queryset:
        `viewer.models.SessionActions.objects.filter()`
    filter fields:
        - `viewer.models.SessionProject.author` - ?author=<str>
        - `viewer.models.SessionProject.session_project` - ?project=<str>
        - `viewer.models.SessionProject.last_update_date` - ?date=<str>

    returns: JSON
        - id: id of the session action record
        - author: id of the user that created the session_project
        - session_project: id of the related session_project
        - last_update_date: Timestamp for when the action list was generated or updated
        - actions: JSON string containing actions related to the session_project

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1,
                    "last_update_date": "2020-10-06T15:36:00Z",
                    "actions": {
                        "save": false,
                        "show": true,
                        "action_type": 1,
                        "object_name": "",
                        "object_type": "",
                        "action_datetime": "2020-09-30T13:44:00.000Z"
                    },
                    "author": 1,
                    "session_project": 1,
                }
            ]

   """
    queryset = SessionActions.objects.filter()
    serializer_class = SessionActionsSerializer

    #   Note: jsonField for Actions will need specific queries - can introduce if needed.
    filter_fields = ('id', 'author', 'session_project', 'last_update_date')


class SnapshotsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about user sessions (snapshots) (GET). Also used for saving
    session information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/snapshots
    queryset:
        `viewer.models.Snapshot.objects.filter()`
    filter class:
        `viewer.filters.SnapshotFilter`
    filter fields:
        - `viewer.models.Snapshot.id` - ?id=<int>
        - `viewer.models.Snapshot.type` - ?type=<str>
        - `viewer.models.Snapshot.author` - ?author=<str>
        - `viewer.models.Snapshot.description` ?description=<str>
        - `viewer.models.Snapshot.created` - ?created=<str>
        - `viewer.models.Snapshot.data` - ?data=<JSON str>
        - `viewer.models.Snapshot.session_project_id` - ?session_project_id=<int>
        - `viewer.models.Snapshot.parent` - ?parent=<int>
        - `viewer.models.Snapshot.children` - ?children=<list>
        - `viewer.models.Snapshot.session_project` - ?session_project=<int>
    returns: JSON
        - id: id of the snapshot
        - type: type of snapshot
        - title: title of snapshot given by author
        - description: description of the snapshot given by author
        - created: timestamp for when the snapshot was created
        - data: json string describing data needed to reproduce state of the snapshot by the front-end
        - session_project: dict describing the project that the snapshot belongs to:
            - id: project id
            - title: project title
            - init_data: timestamp for when the project was initiated
            - description: description of the project given by the author
            - tags: tags given to the project by the author
            - target: id of the target that the project is associated with
            - author: name of the author who created the project
        - parent: parent snapshot id of the current snapshot
        - children: list of children ids of the current snapshot

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 132,
                    "type": "INIT",
                    "title": "-- 2020-07-09 -- 16:01:35",
                    "author": null,
                    "description": "Snapshot generated by anonymous user",
                    "created": "2020-07-09T20:01:36.901552Z",
                    "data": '"{\"apiReducers\":{\"target_id_list\":[{\"id\":2,\"title\":\"NUDT7A\",\'
                    "session_project": {
                        "id": 124,
                        "title": "READ_ONLY",
                        "init_date": "2020-07-09T20:01:35.715324Z",
                        "description": "READ_ONLY",
                        "tags": "[]",
                        "target": 62,
                        "author": null
                    },
                    "parent": null,
                    "children": []
                },]

   """
    queryset = Snapshot.objects.filter()

    def get_serializer_class(self):
        """Determine which serializer to use based on whether the request is a GET or a POST, PUT or PATCH request

        Returns
        -------
        Serializer (rest_framework.serializers.ModelSerializer):
            - if GET: `viewer.serializers.SnapshotReadSerializer`
            - if other: `viewer.serializers.SnapshotWriteSerializer`
        """
        if self.request.method in ['GET']:
            return SnapshotReadSerializer
        return SnapshotWriteSerializer

    filter_class = filters.SnapshotFilter


class SnapshotActionsView(viewsets.ModelViewSet):
    """ Djagno view to retrieve information about actions relating to snapshots (GET). Also used for saving
    snapshot action information (PUT, POST, PATCH)

    Methods
    -------
    url:
        api/snapshot-actions
    queryset:
        `viewer.models.SnapshotActions.objects.filter()`
    filter fields:
        - `viewer.models.SnapshotActions.snapshot` - ?snapshot=<str>
        - `viewer.models.SnapshotActions.last_update_date` - ?date=<str>

    returns: JSON
        - id: id of the snapshot action record
        - author: id of the user that created the snapshot
        - session_project: id of the related session_project (if present)
        - snapshot: id of the related snapshot
        - last_update_date: Timestamp for when the action list was generated or updated
        - actions: JSON string containing actions related to the session_project

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1,
                    "last_update_date": "2020-10-06T15:36:00Z",
                    "actions": {
                        "save": false,
                        "show": true,
                        "action_type": 1,
                        "object_name": "",
                        "object_type": "",
                        "action_datetime": "2020-09-30T13:44:00.000Z"
                    },
                    "author": 1,
                    "session_project": 1,
                    "snapshot": 1
                }
            ]

   """
    queryset = SnapshotActions.objects.filter()
    serializer_class = SnapshotActionsSerializer

    #   Note: jsonField for Actions will need specific queries - can introduce if needed.
    filter_fields = ('id', 'author', 'session_project', 'snapshot', 'last_update_date')

# End of Session Project


### Design sets upload
# Custom parser class for a csv file
class DSetCSVParser(BaseParser):
    """
    CSV parser class specific to design set csv spec - sets media_type for DSetUploadView to text/csv
    """
    media_type = 'text/csv'


class DSetUploadView(APIView):
    """DjangoRF view to upload a design set (PUT) from a csv file

    Methods
    -------
    allowed requests:
        - PUT: takes a csv file and uploads it as a design set (of 2D compounds)
    url:
       viewer/upload_designs
    request params:
        - file (csv file): csv file containing design set information
        - type (str): design set type (options in `viewer.models.DesignSet.set_type`)
        - description (str): short description of the design set - e.g. method of creation
    csv file columns (mandatory):
        - set_name - the name of the design set to upload the molecule to
        - smiles - smiles string for the 2D molecule
        - identifier - an identifier for the molecule
        - inspirations - inspiration molecules from fragalysis used in the design of the 2D molecule

    Returns
    -------
    HTTPResponse (JSON (string))
        A message telling the user whether the upload was successful or not

    """
    parser_class = (DSetCSVParser,)

    def put(self, request, format=None):
        """Method to handle PUT request and upload a design set
        """

        f = request.FILES['file']
        set_type = request.PUT['type']
        set_description = request.PUT['description']

        # save uploaded file to temporary storage
        name = f.name
        path = default_storage.save('tmp/' + name, ContentFile(f.read()))
        tmp_file = str(os.path.join(settings.MEDIA_ROOT, path))

        df = pd.read_csv(tmp_file)
        mandatory_cols = ['set_name', 'smiles', 'identifier', 'inspirations']
        actual_cols = df.columns
        for col in mandatory_cols:
            if col not in actual_cols:
                raise ParseError("The 4 following columns are mandatory: set_name, smiles, identifier, inspirations")

        set_names, compounds = process_design_sets(df, set_type, set_description)

        string = 'Design set(s) successfully created: '

        length = len(set_names)
        string += str(length) + '; '
        for i in range(0, length):
            string += str(i + 1) + ' - ' + set_names[i] + ') number of compounds = ' + str(len(compounds[i])) + '; '

        return HttpResponse(json.dumps(string))


class ComputedSetView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about computed sets

    Methods
    -------
    url:
        api/compound-sets
    queryset:
        `viewer.models.ComputedSet.objects.filter()`
    filter fields:
        - `viewer.models.ComputedSet.target` - ?target=<int>
    returns: JSON
        - name: name of the computed set
        - submitted_sdf: link to the uploaded sdf file
        - spec_version: version of the upload specification used to generate the computed set sdf
        - method_url: link to url describing the methodology used to create the computed set
        - unique_name: auto-generated human-readable name for the computed set
        - target: id for the associated target
        - submitter: id for the associated submitter

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "name": "100threehop2020-07-27S8vv3vx",
                    "submitted_sdf": "http://fragalysis.diamond.ac.uk/media/code/media/compound_sets/Top_100_three_hop_2020-07-27_S8vv3vx.sdf",
                    "spec_version": 1.2,
                    "method_url": "https://github.com/Waztom/xchem-xCOS",
                    "unique_name": "WT-xCOS2-ThreeHop",
                    "target": 62,
                    "submitter": 13
                },]

    """
    queryset = ComputedSet.objects.filter()
    serializer_class = ComputedSetSerializer
    filter_permissions = "project_id"
    filter_fields = ('target',)


class ComputedMoleculesView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about computed molecules - 3D info

    Methods
    -------
    url:
        api/compound-molecules
    queryset:
        `viewer.models.ComputedMolecule.objects.filter()`
    filter fields:
        - `viewer.models.ComputedMolecule.computed_set` - ?computed_set=<int>
    returns: JSON
        - id: id of the molecule
        - sdf_info: 3D coordinates of the molecule in MDL format
        - name: a name for the molecule
        - smiles: SMILES string
        - pdb_info: link to the associated pdb file (apo)
        - compound: id for the associated 2D compound
        - computed_set: name for the associated computed set
        - computed_inspirations: list of ids for the inspirations used in the design/computation of the molecule

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1997,
                    "sdf_info": "FRA-DIA-8640f307-1    RDKit          3D 38 42  0  0  0  0  0  0  0  0999 V2000..."
                    "name": "FRA-DIA-8640f307-1",
                    "smiles": "CC(=O)NCCc1c[nH]c2c([C@H](CN(Cc3cc(C)on3)C(=O)NC3CC3)c3nnc(C)s3)cc(F)cc12",
                    "pdb_info": "http://fragalysis.diamond.ac.uk/media/pdbs/Fragmenstein_J6Sfvrs.pdb",
                    "compound": 4030,
                    "computed_set": "100XCOS2Teo2020-07-23yuZJZFY",
                    "computed_inspirations": []
                },]


    """
    queryset = ComputedMolecule.objects.filter()
    serializer_class = ComputedMoleculeSerializer
    filter_permissions = "project_id"
    filter_fields = ('computed_set',)


class NumericalScoresView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about numerical computed molecule scores

    Methods
    -------
    url:
        api/numerical-scores
    queryset:
        `viewer.models.NumericalScoreValues.objects.filter()`
    filter fields:
        - `viewer.models.NumericalScoreValues.compound` - ?compound=<int>
        - `viewer.models.NumericalScoreValues.score` - ?score=<int>
    returns: JSON
        - id: id of the score
        - score: dict of the score info:
            - id: id of the score description
            - name: name of the score
            - description: description of the score
            - computed_set: name of the computed set that the score is associated to
        - value: numerical value of the score
        - compound: id of the associated compound object

    example output:

        .. code-block:: javascript

            "results": [
                "results": [
                    {
                        "id": 8145,
                        "score": {
                            "id": 48,
                            "name": "Score_1",
                            "description": "The score is scaled by the number of bit atoms",
                            "computed_set": "100XCOS2Teo2020-07-23yuZJZFY"
                        },
                        "value": 19.8653,
                        "compound": 1997
                    },


    """

    queryset = NumericalScoreValues.objects.filter()
    serializer_class = NumericalScoreSerializer
    filter_permissions = "project_id"
    filter_fields = ('compound', 'score')


class TextScoresView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve information about text computed molecule scores

    Methods
    -------
    url:
        api/text-scores
    queryset:
        `viewer.models.TextScoreValues.objects.filter()`
    filter fields:
        - `viewer.models.TextScoreValues.compound` - ?compound=<int>
        - `viewer.models.TextScoreValues.score` - ?score=<int>
    returns: JSON
        - id: id of the score
        - score: dict of the score info:
            - id: id of the score description
            - name: name of the score
            - description: description of the score
            - computed_set: name of the computed set that the score is associated to
        - value: text value of the score
        - compound: id of the associated compound object

    example output:

        .. code-block:: javascript

            "results": [
                "results": [
                    {
                        "id": 8145,
                        "score": {
                            "id": 48,
                            "name": "Score_1",
                            "description": "Desctription",
                            "computed_set": "100XCOS2Teo2020-07-23yuZJZFY"
                        },
                        "value": "Yes",
                        "compound": 1997
                    },


    """
    queryset = TextScoreValues.objects.filter()
    serializer_class = TextScoreSerializer
    filter_permissions = "project_id"
    filter_fields = ('compound', 'score')


class CompoundScoresView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve descriptions of scores for a given name or computed set

    Methods
    -------
    url:
        api/compound-scores
    queryset:
        `viewer.models.ScoreDescription.objects.filter()`
    filter fields:
        - `viewer.models.ScoreDescription.computed_set` - ?computed_set=<int>
        - `viewer.models..ScoreDescription.name` - ?name=<str>
    returns: JSON
        - id: id of the score
        - score: dict of the score info:
            - id: id of the score description
            - name: name of the score
            - description: description of the score
            - computed_set: name of the computed set that the score is associated to

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 22,
                    "name": "FeatureSteinScore",
                    "description": "FeatureStein Score",
                    "computed_set": "top26062020axX6Vqt"
                },]


    """
    queryset = ScoreDescription.objects.filter()
    serializer_class = ScoreDescriptionSerializer
    filter_permissions = "project_id"
    filter_fields = ('computed_set', 'name')


class ComputedMolAndScoreView(viewsets.ReadOnlyModelViewSet):
    """ DjagnoRF view to retrieve all information about molecules from a computed set, along with all of their scores

    Methods
    -------
    url:
        api/compound-mols-scores
    queryset:
        `viewer.models.ComputedMolecule.objects.filter()`
    filter fields:
        - `viewer.models.ComputedMolecule.computed_set` - ?computed_set=<int>
    returns: JSON
        - id: id of the molecule
        - sdf_info: 3D coordinates of the molecule in MDL format
        - name: a name for the molecule
        - smiles: SMILES string
        - pdb_info: link to the associated pdb file (apo)
        - compound: id for the associated 2D compound
        - computed_set: name for the associated computed set
        - computed_inspirations: list of ids for the inspirations used in the design/computation of the molecule
        - numerical_scores: dict of numerical scores, where each key is a score name, and each value is the associated score
        - text_scores: dict of text scores, where each key is a score name, and each value is the associated score

    example output:

        .. code-block:: javascript

            "results": [
                {
                    "id": 1997,
                    "sdf_info": "FRA-DIA-8640f307-1     RDKit          3D 38 42  0  0  0  0  0  0  0"
                    "name": "FRA-DIA-8640f307-1",
                    "smiles": "CC(=O)NCCc1c[nH]c2c([C@H](CN(Cc3cc(C)on3)C(=O)NC3CC3)c3nnc(C)s3)cc(F)cc12",
                    "pdb_info": "http://fragalysis.diamond.ac.uk/media/pdbs/Fragmenstein_J6Sfvrs.pdb",
                    "compound": 4030,
                    "computed_set": "100XCOS2Teo2020-07-23yuZJZFY",
                    "computed_inspirations": [],
                    "numerical_scores": {
                        "Score_1": 19.8653,
                        "N_hits": 4.0
                    },
                    "text_scores": {}
                },]


    """
    queryset = ComputedMolecule.objects.filter()
    serializer_class = ComputedMolAndScoreSerializer
    filter_permissions = "project_id"
    filter_fields = ('computed_set',)
